function updateSpreadsheetData() {
  try {
    const CONFIG = {
      spreadsheetId: '1GXKS4kV-TWX2eJFX0dFArjeJEj0QlcbUHrm6iVq-oh8',
      sheetName: "HIFS",
      folderId: '1iSAW15y_KbgNMrfGhHLBYDxOzfY-BOCG'
    };

    const sheet = SpreadsheetApp.openById(CONFIG.spreadsheetId).getSheetByName(CONFIG.sheetName);
    if (!sheet) {
      throw new Error(`Sheet '${CONFIG.sheetName}' not found.`);
    }

    const data = sheet.getDataRange().getValues();
    const currentYear = new Date().getFullYear().toString();
    Logger.log(`üìÖ Current Year: ${currentYear}`);

    const yearRowIndex = data.findIndex(row => row[0]?.toString().trim() === currentYear);
    if (yearRowIndex === -1) {
      throw new Error(`Year row '${currentYear}' not found in the sheet.`);
    }

    const headerText = getPreviousWeekDateRangeFormatted();
    const headerColumnIndex = ensureDateHeader(sheet, data[yearRowIndex], yearRowIndex, headerText);
    Logger.log(`üìç Target Row: ${yearRowIndex + 1}, Target Column: ${headerColumnIndex + 1}`);

    updateHIFStartedCount(sheet, data, yearRowIndex, headerColumnIndex, CONFIG.folderId);
    updateCumulativeCount(sheet, data, headerColumnIndex, CONFIG.folderId);
    updateEligibleAssignments(sheet, data, headerColumnIndex, CONFIG.folderId);
    updateYearlyIncreaseOrDecrease(sheet, data, headerColumnIndex);
    updateNotAssignmentEligible(sheet, data, headerColumnIndex);


    updateLLCApplicationsSubmitted(sheet, data, headerColumnIndex, CONFIG.folderId);
    updateLLCInterestNoted(sheet, data, headerColumnIndex, CONFIG.folderId);

  } catch (error) {
    Logger.log(`‚ùå Error: ${error.message}`);
  }
}

function getPreviousWeekDateRangeFormatted() {
  try {
    const today = new Date();
    const day = today.getDay();
    const lastMonday = new Date(today);
    lastMonday.setDate(today.getDate() - (day === 0 ? 6 : day - 1) - 7);
    const lastSunday = new Date(lastMonday);
    lastSunday.setDate(lastMonday.getDate() + 6);
    return `${formatDate(lastMonday)} - ${formatDate(lastSunday)}`;
  } catch (error) {
    Logger.log(`‚ùå Error calculating date range: ${error.message}`);
    throw error; // Rethrow to propagate the error
  }
}

function formatDate(date) {
  try {
    return Utilities.formatDate(date, Session.getScriptTimeZone(), "MM/dd/yyyy");
  } catch (error) {
    Logger.log(`‚ùå Error formatting date: ${error.message}`);
    throw error; // Rethrow to propagate the error
  }
}

function ensureDateHeader(sheet, yearRow, yearRowIndex, headerText) {
  try {
    let colIndex = yearRow.indexOf(headerText);
    if (colIndex === -1) {
      colIndex = yearRow.findIndex((val, i) => i > 0 && val === "");
      if (colIndex === -1) colIndex = yearRow.length;
      sheet.getRange(yearRowIndex + 1, colIndex + 1).setValue(headerText);
      Logger.log(`‚úÖ Inserted date header: ${headerText}`);
    } else {
      Logger.log(`‚ÑπÔ∏è Date header already exists: ${headerText}`);
    }
    return colIndex;
  } catch (error) {
    Logger.log(`‚ùå Error ensuring date header: ${error.message}`);
    throw error; // Rethrow to propagate the error
  }
}

function updateHIFStartedCount(sheet, data, yearRowIndex, colIndex, folderId) {
  try {
    const targetRowIndex = yearRowIndex + 1;
    const rowLabel = data[targetRowIndex]?.[0]?.toString().trim();

    if (rowLabel === "HIF Started (not signed or completed)") {
      const count = getCSVStatusCount(folderId, ["HIF Started"]);
      if (count !== null) {
        sheet.getRange(targetRowIndex + 1, colIndex + 1).setValue(count);
        Logger.log(`‚úÖ Inserted HIF Started count: ${count}`);
      } else {
        Logger.log("‚ùå Could not retrieve HIF Started count.");
      }
    } else {
      Logger.log("‚ùå 'HIF Started (not signed or completed)' row not found immediately after the year row.");
    }
  } catch (error) {
    Logger.log(`‚ùå Error updating HIF Started count: ${error.message}`);
  }
}

function updateCumulativeCount(sheet, data, colIndex, folderId) {
  try {
    const currentYear = new Date().getFullYear().toString();
    const yearRowIndex = data.findIndex(row => row[0]?.toString().trim() === currentYear);
    
    if (yearRowIndex === -1) {
      Logger.log(`‚ùå Year row '${currentYear}' not found.`);
      return;
    }

    const rowLabel = "Cumulative total Completed*/Signed (no started)";
    let targetRowIndex = -1;

    for (let i = yearRowIndex + 1; i < Math.min(data.length, yearRowIndex + 20); i++) {
      if (data[i][0]?.toString().trim() === rowLabel) {
        targetRowIndex = i;
        break;
      }
    }

    if (targetRowIndex !== -1) {
      const cellValue = sheet.getRange(targetRowIndex + 1, colIndex + 1).getValue();
      Logger.log(`üîç Checking cell: Row ${targetRowIndex + 1}, Col ${colIndex + 1}, Current Value: ${cellValue}`);

      if (cellValue === "" || cellValue === null || cellValue.toString().trim() === "") {
        const count = getCSVStatusCount(folderId, ["HIF Signed", "HIF Completed"]);
        if (count !== null) {
          sheet.getRange(targetRowIndex + 1, colIndex + 1).setValue(count);
          Logger.log(`‚úÖ Inserted cumulative count: ${count}`);
        } else {
          Logger.log("‚ùå Could not retrieve cumulative count.");
        }
      } else {
        Logger.log(`‚ÑπÔ∏è Cell already has value (${cellValue}); skipping update.`);
      }

      updateCumulativeTotalWithStarted(sheet, data, colIndex, targetRowIndex, folderId);
    } else {
      Logger.log(`‚ùå '${rowLabel}' row not found under year ${currentYear}.`);
    }
  } catch (error) {
    Logger.log(`‚ùå Error updating cumulative count: ${error.message}`);
  }
}

function updateCumulativeTotalWithStarted(sheet, data, colIndex, cumulativeRowIndex, folderId) {
  try {
    const currentYear = new Date().getFullYear().toString();
    const rowLabel = 'Cumulative Total with "started" ones included';
    let targetRowIndex = -1;

    for (let i = cumulativeRowIndex + 1; i < Math.min(data.length, cumulativeRowIndex + 20); i++) {
      const label = data[i][0]?.toString().trim();
      Logger.log(`üîé Checking row ${i + 1}: '${label}'`);
      if (label === rowLabel) {
        targetRowIndex = i;
        break;
      }
    }

    if (targetRowIndex !== -1) {
      const hifStartedVal = getCSVStatusCount(folderId, ["HIF Started"]);
      const cumulativeVal = getCSVStatusCount(folderId, ["HIF Signed", "HIF Completed"]);

      Logger.log(`üîç From CSV ‚Äî HIF Started: ${hifStartedVal}, Completed/Signed: ${cumulativeVal}`);
      const total = hifStartedVal + cumulativeVal;

      const existingVal = sheet.getRange(targetRowIndex + 1, colIndex + 1).getValue();
      if (!existingVal || existingVal.toString().trim() === "") {
        sheet.getRange(targetRowIndex + 1, colIndex + 1).setValue(total);
        Logger.log(`‚úÖ Set combined total (${rowLabel}): ${total}`);
      } else {
        Logger.log(`‚ÑπÔ∏è Cell already has value (${existingVal}); skipping update.`);
      }
    } else {
      Logger.log(`‚ùå '${rowLabel}' row not found under year ${currentYear}.`);
    }
  } catch (error) {
    Logger.log(`‚ùå Error updating cumulative total with started: ${error.message}`);
  }
}

// Add similar try-catch blocks to other functions like updateEligibleAssignments, updateNonEligibleAssignments, etc.

function getCSVStatusCount(folderId, targetStatuses) {
  try {
    const folder = DriveApp.getFolderById(folderId);
    const files = folder.getFilesByType(MimeType.CSV);

    if (!files.hasNext()) {
      Logger.log('‚ùå No CSV files found in the folder.');
      return null;
    }

    const file = files.next();
    const csvData = Utilities.parseCsv(file.getBlob().getDataAsString());
    const headers = csvData[0];
    const statusColumnIndex = headers.findIndex(header => header.toLowerCase().includes("status"));

    if (statusColumnIndex === -1) {
      Logger.log('‚ùå Status column not found in CSV file.');
      return null;
    }

    targetStatuses = targetStatuses.map(status => status.toLowerCase());

    const filteredRows = csvData.slice(1).filter(row => {
      const status = row[statusColumnIndex]?.trim().toLowerCase();
      return targetStatuses.some(statusText => status === statusText);
    });

    Logger.log(`üîç Filtered Rows Count: ${filteredRows.length}`);
    return filteredRows.length;
  } catch (error) {
    Logger.log(`‚ùå Error getting CSV status count: ${error.message}`);
    return null; // Return null in case of error
  }
}
function updateEligibleAssignments(sheet, data, colIndex, folderId) {
  try {
    const year = new Date().getFullYear().toString(); // Should be 2025
    const rowLabel = 'HIF Completed/Signed assignment eligible';
    
    const yearRowIndex = data.findIndex(row => row[0]?.toString().trim() === year);
    if (yearRowIndex === -1) {
      Logger.log(`‚ùå Year row '${year}' not found.`);
      return;
    }

    let targetRowIndex = -1;

    // üîç Only look under the current year's section
    for (let i = yearRowIndex + 1; i < data.length; i++) {
      const currentLabel = data[i][0]?.toString().trim();
      if (currentLabel === '') continue;
      if (currentLabel === rowLabel) {
        targetRowIndex = i;
        break;
      }
      // Stop scanning if we hit another year
      if (/^\d{4}$/.test(currentLabel)) break;
    }

    if (targetRowIndex === -1) {
      Logger.log(`‚ùå '${rowLabel}' not found under year ${year}.`);
      return;
    }

    Logger.log(`‚úÖ Found '${rowLabel}' under ${year} at row ${targetRowIndex + 1}`);

    // ‚úÖ Get CSV
    const folder = DriveApp.getFolderById(folderId);
    const files = folder.getFilesByType(MimeType.CSV);
    if (!files.hasNext()) {
      Logger.log("‚ùå No CSV files found.");
      return;
    }

    const file = files.next();
    const csvData = Utilities.parseCsv(file.getBlob().getDataAsString());
    const headers = csvData[0].map(h => h.trim().toLowerCase());

    const efPaidIndex = headers.indexOf("ef paid");
    const arRegIndex = headers.indexOf("a&r registration date");
    const contractSignedIndex = headers.indexOf("contract signed date");

    if (efPaidIndex === -1 || arRegIndex === -1 || contractSignedIndex === -1) {
      Logger.log("‚ùå Missing required columns in CSV.");
      return;
    }

    const filteredRows = csvData.slice(1).filter(row =>
      row[efPaidIndex]?.trim() !== "" &&
      row[arRegIndex]?.trim() !== "" &&
      row[contractSignedIndex]?.trim() !== ""
    );

    const count = filteredRows.length;
    const cell = sheet.getRange(targetRowIndex + 1, colIndex + 1);
    const existingVal = cell.getValue();

    Logger.log(`üß™ Existing value: ${existingVal}, New count: ${count}`);

    if (!existingVal || parseInt(existingVal, 10) !== count) {
      cell.setValue(count);
      Logger.log(`‚úÖ Set '${rowLabel}' to ${count}`);
    } else {
      Logger.log(`‚ÑπÔ∏è No update needed for '${rowLabel}'`);
    }

  } catch (error) {
    Logger.log(`‚ùå Error updating eligible assignments: ${error.message}`);
  }
}

function updateYearlyIncreaseOrDecrease(sheet, data, colIndex) {
  try {
    const currentYear = new Date().getFullYear();
    const previousYear = currentYear - 1;
    const rowLabel = 'Increase/decrease (2024 to 2025, using grey total for both)';

    // Find the target row
    const targetRowIndex = data.findIndex(row => row[0]?.toString().trim() === rowLabel);
    if (targetRowIndex === -1) {
      Logger.log(`‚ùå Row for '${rowLabel}' not found.`);
      return;
    }

    // Find cumulative row index for both years
    const getCumulativeValue = (year) => {
      const yearRowIndex = data.findIndex(row => row[0]?.toString().trim() === year.toString());
      if (yearRowIndex === -1) {
        Logger.log(`‚ùå Year row '${year}' not found.`);
        return null;
      }

      for (let i = yearRowIndex + 1; i < Math.min(data.length, yearRowIndex + 20); i++) {
        if (data[i][0]?.toString().trim() === "Cumulative total Completed*/Signed (no started)") {
          const val = sheet.getRange(i + 1, colIndex + 1).getValue();
          return parseInt(val, 10) || 0;
        }
      }

      Logger.log(`‚ùå Cumulative total row not found under year ${year}.`);
      return null;
    };

    const currentValue = getCumulativeValue(currentYear);
    const previousValue = getCumulativeValue(previousYear);

    if (currentValue === null || previousValue === null) {
      Logger.log("‚ùå Could not retrieve cumulative values for both years.");
      return;
    }

    const difference = currentValue - previousValue;

    // Set the value in the target row
    sheet.getRange(targetRowIndex + 1, colIndex + 1).setValue(difference);
    Logger.log(`‚úÖ Updated '${rowLabel}' with value: ${difference}`);
  } catch (error) {
    Logger.log(`‚ùå Error updating yearly increase/decrease: ${error.message}`);
  }
}

function updateNotAssignmentEligible(sheet, data, colIndex) {
  try {
    const currentYear = new Date().getFullYear().toString();

    // Locate cumulative completed/signed row
    const yearRowIndex = data.findIndex(row => row[0]?.toString().trim() === currentYear);
    if (yearRowIndex === -1) {
      Logger.log(`‚ùå Year row '${currentYear}' not found.`);
      return;
    }

    let cumulativeRowIndex = -1;
    let eligibleRowIndex = -1;
    let targetRowIndex = -1;

    for (let i = yearRowIndex + 1; i < data.length; i++) {
      const rowLabel = data[i][0]?.toString().trim();
      if (rowLabel === "Cumulative total Completed*/Signed (no started)") cumulativeRowIndex = i;
      if (rowLabel === "HIF Completed/Signed assignment eligible") eligibleRowIndex = i;
      if (rowLabel === "HIF Completed/Signed NOT assignment eligible") targetRowIndex = i;
      if (cumulativeRowIndex !== -1 && eligibleRowIndex !== -1 && targetRowIndex !== -1) break;
    }

    if (cumulativeRowIndex === -1 || eligibleRowIndex === -1 || targetRowIndex === -1) {
      Logger.log(`‚ùå One or more required rows not found.`);
      return;
    }

    const cumulativeVal = parseInt(sheet.getRange(cumulativeRowIndex + 1, colIndex + 1).getValue(), 10) || 0;
    const eligibleVal = parseInt(sheet.getRange(eligibleRowIndex + 1, colIndex + 1).getValue(), 10) || 0;
    const notEligibleVal = cumulativeVal - eligibleVal;

    sheet.getRange(targetRowIndex + 1, colIndex + 1).setValue(notEligibleVal);
    Logger.log(`‚úÖ Set 'HIF Completed/Signed NOT assignment eligible' to: ${notEligibleVal}`);
  } catch (error) {
    Logger.log(`‚ùå Error updating 'HIF Completed/Signed NOT assignment eligible': ${error.message}`);
  }
}
function updateLLCApplicationsSubmitted(sheet, data, headerColumnIndex, folderId) {
  try {
    const currentYear = new Date().getFullYear().toString();
    const rowLabel = "LLC Applications Submitted";

    // Find the year row and ensure it exists
    const yearRowIndex = data.findIndex(row => row[0]?.toString().trim() === currentYear);
    if (yearRowIndex === -1) {
      Logger.log(`‚ùå Year row '${currentYear}' not found.`);
      return;
    }

    let targetRowIndex = -1;

    // Look for the row labeled "LLC Applications Submitted" under the current year section
    for (let i = yearRowIndex + 1; i < data.length; i++) {
      const currentLabel = data[i][0]?.toString().trim();
      if (currentLabel === '') continue; // Skip empty rows
      if (currentLabel === rowLabel) {
        targetRowIndex = i;
        break;
      }
      // Stop scanning if we hit another year
      if (/^\d{4}$/.test(currentLabel)) break;
    }

    if (targetRowIndex === -1) {
      Logger.log(`‚ùå '${rowLabel}' not found under year ${currentYear}.`);
      return;
    }

    Logger.log(`‚úÖ Found '${rowLabel}' under ${currentYear} at row ${targetRowIndex + 1}`);

    // Retrieve CSV file from the folder
    const folder = DriveApp.getFolderById(folderId);
    const files = folder.getFilesByType(MimeType.CSV);

    if (!files.hasNext()) {
      Logger.log("‚ùå No CSV files found.");
      return;
    }

    const file = files.next();
    const csvData = Utilities.parseCsv(file.getBlob().getDataAsString());
    const headers = csvData[0].map(h => h.trim().toLowerCase());

    const llcApPulledIndex = headers.indexOf("llc ap pulled");

    if (llcApPulledIndex === -1) {
      Logger.log("‚ùå 'LLC Ap Pulled' column not found in CSV.");
      return;
    }

    // Filter rows where "LLC Ap Pulled" is true
    const filteredRows = csvData.slice(1).filter(row =>
      row[llcApPulledIndex]?.trim().toLowerCase() === "true"
    );

    const count = filteredRows.length;
    const cell = sheet.getRange(targetRowIndex + 1, headerColumnIndex + 1);
    const existingVal = cell.getValue();

    Logger.log(`üß™ Existing value: ${existingVal}, New count: ${count}`);

    if (!existingVal || parseInt(existingVal, 10) !== count) {
      cell.setValue(count);
      Logger.log(`‚úÖ Set '${rowLabel}' to ${count}`);
    } else {
      Logger.log(`‚ÑπÔ∏è No update needed for '${rowLabel}'`);
    }

  } catch (error) {
    Logger.log(`‚ùå Error updating LLC Applications Submitted: ${error.message}`);
  }
}
function updateLLCInterestNoted(sheet, data, headerColumnIndex, folderId) {
  try {
    const currentYear = new Date().getFullYear().toString();
    const rowLabel = "LLC interest noted";

    // Find the year row and ensure it exists
    const yearRowIndex = data.findIndex(row => row[0]?.toString().trim() === currentYear);
    if (yearRowIndex === -1) {
      Logger.log(`‚ùå Year row '${currentYear}' not found.`);
      return;
    }

    let targetRowIndex = -1;

    // Look for the row labeled "LLC Interest Noted" under the current year section
    for (let i = yearRowIndex + 1; i < data.length; i++) {
      const currentLabel = data[i][0]?.toString().trim();
      if (currentLabel === '') continue; // Skip empty rows
      if (currentLabel === rowLabel) {
        targetRowIndex = i;
        break;
      }
      // Stop scanning if we hit another year
      if (/^\d{4}$/.test(currentLabel)) break;
    }

    if (targetRowIndex === -1) {
      Logger.log(`‚ùå '${rowLabel}' not found under year ${currentYear}.`);
      return;
    }

    Logger.log(`‚úÖ Found '${rowLabel}' under ${currentYear} at row ${targetRowIndex + 1}`);

    // Retrieve CSV file from the folder
    const folder = DriveApp.getFolderById(folderId);
    const files = folder.getFilesByType(MimeType.CSV);

    if (!files.hasNext()) {
      Logger.log("‚ùå No CSV files found.");
      return;
    }

    const file = files.next();
    const csvData = Utilities.parseCsv(file.getBlob().getDataAsString());
    const headers = csvData[0].map(h => h.trim().toLowerCase());

    const llcInterestIndex = headers.indexOf("llc interest");

    if (llcInterestIndex === -1) {
      Logger.log("‚ùå 'LLC Interest' column not found in CSV.");
      return;
    }

    // Filter rows where "LLC Interest" is true
    const filteredRows = csvData.slice(1).filter(row =>
      row[llcInterestIndex]?.trim().toLowerCase() === "true"
    );

    const count = filteredRows.length;
    const cell = sheet.getRange(targetRowIndex + 1, headerColumnIndex + 1);
    const existingVal = cell.getValue();

    Logger.log(`üß™ Existing value: ${existingVal}, New count: ${count}`);

    if (!existingVal || parseInt(existingVal, 10) !== count) {
      cell.setValue(count);
      Logger.log(`‚úÖ Set '${rowLabel}' to ${count}`);
    } else {
      Logger.log(`‚ÑπÔ∏è No update needed for '${rowLabel}'`);
    }

  } catch (error) {
    Logger.log(`‚ùå Error updating LLC Interest Noted: ${error.message}`);
  }
}


